---
content_type: page
description: ''
learning_resource_types:
- Lecture Notes
ocw_type: CourseSection
parent_title: Lecture Notes
parent_type: CourseSection
parent_uid: dd846b6b-f0c7-fd62-35a9-4e87d772d0e9
title: Graphical Programs
uid: f924b6c1-3f76-371e-859a-f0c6319d9c5b
video_files:
  video_thumbnail_file: null
video_metadata:
  youtube_id: null
---

Topics 
-------

1.  [Introduction](#1)
2.  [The Java® Event Model](#2)
3.  [Laying Out User Interface Components](#3)
4.  [Swing Component Overview](#4)

{{< anchor "1" >}}{{< /anchor >}}1\. Introduction
-------------------------------------------------

Graphical programs require a very different programming model to the non-graphical programs we have encountered in the past. A non-graphical program typically runs straight through from beginning to end. By contrast, a graphical program should be capable of running indefinitely, accepting input through the graphical user interface (GUI) and responding accordingly. This kind of programming is known as _event-driven programming_, because the program's sequence of operation is determined by _events_ generated by the GUI components. The program responds to events by invoking functions known as _event handlers_ . For example, pushing the _Print_ button may generate a "button-pushed" event, which results in a call to an event handler named _print()_.

In general, a graphical program consists of the following key elements:

*   Code to create GUI components, such as buttons, text areas, scrollable views, etc.
*   Code that lays out the components within a container. Examples of containers are frames, which are stand-alone windows, and applets, which are windows that are embedded within a web page.
*   Event handling code that specifies what should happen when the user interacts with the GUI components.
*   An _event loop_, whose job is to wait for events to occur and to call appropriate event handlers.

The following pseudo-code illustrates how the event loop might work

 _while (true) {                                        // The event loop._  
 _// Get the next event from the event queue._  
 _Event e = get\_next\_event();_

 _// Process the events by calling appropriate event handlers._  
 _if (e.eventType == QUIT) {_  
 _exit();                                           // Terminate the program._  
 _}_  
 _else if (e.eventType == BUTTON\_PUSHED) {_  
 _if (e.eventSource == PRINT\_BUTTON)_  
 _print(e);                                   // Print out the current page._  
 _else {_  
 _..._  
 _}_  
 _}_  
 _else {_  
 _..._  
 _}_  
 _}_

In C++, the programmer must often explicitly write an event loop similar to the one shown above. This can involve a lot of work, so Java® attempts to shield the programmer from the actual event loop, while still providing a flexible way to specify how events are processed.

{{< anchor "2" >}}{{< /anchor >}}2\. The Java® Event Model (JDK 1.1 and above)
------------------------------------------------------------------------------

_(Ref. [Java® Tutorial](http://java.sun.com/docs/books/tutorial/uiswing/learn/index.html))_

The Java® event model is based on the notion of _event sources_ and _event listeners_.

An _event source_ is most frequently a user interface component (such as a button, menu item or scrollable view), which can notify registered listeners when events of interest occur. Note that an event source may generate both high level events e.g. button click, as well as low level events, e.g. mouse press.

An _event listener_ is an object that can register an interest in receiving certain types of events from an event source. The event source sends out event notifications by calling an appropriate event handling method in the event listener object.

The event listener registration and notification process takes place according to _event type_ . An object wishing to listen to events of a particular type must implement the corresponding _event listener interface_ . The interface simply specifies a standard set of event handling functions that the listener object must provide.

Here is a list of events, and their corresponding event types and event listener interfaces.

{{< tableopen >}}
{{< theadopen >}}
{{< tropen >}}
{{< thopen >}}
EVENT
{{< thclose >}}
{{< thopen >}}
EVENT TYPE
{{< thclose >}}
{{< thopen >}}
EVENT LISTENER INTERFACE
{{< thclose >}}

{{< trclose >}}

{{< theadclose >}}
{{< tropen >}}
{{< tdopen >}}
Button click, menu selection, text field entry
{{< tdclose >}}
{{< tdopen >}}
ActionEvent
{{< tdclose >}}
{{< tdopen >}}
ActionListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Resizing, moving, showing or hiding a component
{{< tdclose >}}
{{< tdopen >}}
ComponentEvent
{{< tdclose >}}
{{< tdopen >}}
ComponentListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Mouse press, mouse release, mouse click, mouse enter, mouse exit
{{< tdclose >}}
{{< tdopen >}}
MouseEvent
{{< tdclose >}}
{{< tdopen >}}
MouseListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Mouse move, mouse drag
{{< tdclose >}}
{{< tdopen >}}
MouseEvent
{{< tdclose >}}
{{< tdopen >}}
MouseMotionListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Key press, key release
{{< tdclose >}}
{{< tdopen >}}
KeyEvent
{{< tdclose >}}
{{< tdopen >}}
KeyListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Gain keyboard focus, lose keyboard focus
{{< tdclose >}}
{{< tdopen >}}
FocusEvent
{{< tdclose >}}
{{< tdopen >}}
FocusListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Window closing, window iconified, window deiconified
{{< tdclose >}}
{{< tdopen >}}
WindowEvent
{{< tdclose >}}
{{< tdopen >}}
WindowListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Scrolling
{{< tdclose >}}
{{< tdopen >}}
AdjustmentEvent
{{< tdclose >}}
{{< tdopen >}}
AdjustmentListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Item selection e.g. checkbox, list item
{{< tdclose >}}
{{< tdopen >}}
ItemEvent
{{< tdclose >}}
{{< tdopen >}}
ItemListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Return key pressed
{{< tdclose >}}
{{< tdopen >}}
TextEvent
{{< tdclose >}}
{{< tdopen >}}
TextListener
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
Adding/removing a component to/from a container
{{< tdclose >}}
{{< tdopen >}}
ContainerEvent
{{< tdclose >}}
{{< tdopen >}}
ContainerListener
{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}

The general approach to implementing an event listener is the same in every case.

*   Write a class that implements the appropriate _XXXListener_ interface.
*   Create an object of type _XXXListener_.
*   Register the event listener object with an event source by calling the event source's _addXXXListener_ method.

The following example shows how to create a frame. When the frame is closed, we want to make sure that the program terminates, since this does not happen automatically. We can use a WindowListener to do this.

_import javax.swing.\*;_  
_import java.awt.event.\*;_

 _public class Main {_  
 _public static void main(String\[\] args) {_  
 _// Create a window.  Then set its size and make it visible._  
 _JFrame frame = new JFrame("Main window");_  
 _frame.setSize(400,400);_  
 _frame.setVisible(true);_

 _// Make the program terminate when the frame is closed.  We do this by registering a window listener_  
 _// to receive WindowEvents from the frame.  The window listener will provide an event handler called_  
 _// windowClosing, which will be called when the frame is closed._  
 _WindowListener listener = new MyWindowListener();                 // A class that we write._  
 _frame.addWindowListener(listener);_  
 _}_  
_}_

_// Here is our window listener.  We are only interested in windowClosing, however, we must provide_  
_// implementations for all of the methods in the WindowListener interface._  
_class MyWindowListener implements WindowListener {_  
 _public void windowClosing(WindowEvent e) {_  
 _System.out.println("Terminating the program now.");_  
 _System.exit(0);_  
 _}_  
 _public void windowClosed(WindowEvent e) {}_  
 _public void windowOpened(WindowEvent e) {}_  
 _public void windowActivated(WindowEvent e) {}_  
 _public void windowDeactivated(WindowEvent e) {}_  
 _public void windowIconified(WindowEvent e) {}_  
 _public void windowDeiconified(WindowEvent e) {}_  
_}_  
 

Unfortunately, this example involves quite a lot of code. There are a couple of ways to simplify the program

Anonymous Classes
-----------------

An anonymous class is a class that has no name. It is declared an instantiated within a single expression. Here is how we could use an anonymous class to simplify the closable frame example:

_import javax.swing.\*;_  
_import java.awt.event.\*;_

 _public class Main {_  
 _public static void main(String\[\] args) {_  
 _// Create a window.  Then set its size and make it visible._  
 _JFrame frame = new JFrame("Main window");_  
 _frame.setSize(400,400);_  
 _frame.setVisible(true);_

 _// Make the frame closable.  Here we have used an anonymous class that implements the_  
 _// WindowListener interface._  
 _frame.addWindowListener(new WindowListener() {_  
 _public void windowClosing(WindowEvent e) {_  
 _System.out.println("Terminating the program now.");_  
 _System.exit(0);_  
 _}_  
 _public void windowClosed(WindowEvent e) {}_  
 _public void windowOpened(WindowEvent e) {}_  
 _public void windowActivated(WindowEvent e) {}_  
 _public void windowDeactivated(WindowEvent e) {}_  
 _public void windowIconified(WindowEvent e) {}_  
 _public void windowDeiconified(WindowEvent e) {}_  
 _});_  
 _}_  
_}_

Event Adapters
--------------

An event adapter is just a class that implements an event listener interface, with empty definitions for all of the functions. The idea is that if we subclass the event adapter, we will only have to override the functions that we are interested in. The closable frame example can thus be shortened to:

_import javax.swing.\*;_  
_import java.awt.event.\*;_

 _public class Main {_  
 _public static void main(String\[\] args) {_  
 _// Create a window.  Then set its size and make it visible._  
 _JFrame frame = new JFrame("Main window");_  
 _frame.setSize(400,400);_  
 _frame.setVisible(true);_

 _// Make the frame closable.  Here we have used an anonymous class that extends WindowAdapter._  
 _frame.addWindowListener(new WindowAdapter() {_  
 _public void windowClosing(WindowEvent e) {    // This overrides the empty base class method._  
 _System.out.println("Terminating the program now.");_  
 _System.exit(0);_  
 _}_  
 _});_  
 _}_  
_}_

{{< anchor "3" >}}{{< /anchor >}}3\. Laying Out User Interface Components
-------------------------------------------------------------------------

Containers
----------

_(Ref. [Java® Tutorial](http://java.sun.com/docs/books/tutorial/uiswing/learn/index.html))_

A _Container_ is a GUI component that can hold other GUI components. Three commonly used container classes are

_JFrame_ - This is a stand-alone window with a title bar, menubar and a border. It is typically used as the top-level container for a graphical Java® application.

_JApplet_ - This is a container that can be embedded within an HTML page. It is typically used as the top-level container for a Java® applet.

_JPanel_ - This is a container that must reside within another container. It provides a way to group several components (e.g. buttons) as a single unit, when they are laid out on the screen.  _JPanel_ can also be used as an area for drawing operations. (When used in this way, it can provide automatic double buffering, which is a technique for producing flicker-free animation.)

A component object, _myComponent_, can be added to a container object, _myContainer_, using a statement of the form

    _myContainer.getContentPane().add(myComponent);_

The following example illustrates how to add a _JButton_ instance to an instance of _JFrame_.

_import javax.swing.\*;_  
_import java.awt.event.\*;_

 _public class Main {_  
 _public static void main(String\[\] args) {_  
 _// Create a window._  
 _JFrame frame = new JFrame("Main window");_  
 _frame.setSize(400,400);_

 _// Create a button and add it to the frame._  
 _JButton button = new JButton("Click me");_  
 _frame.getContentPane().add(button);_

 _// Add an event handler for button clicks._  
 _button.addActionListener(new ActionListener() {_  
 _public void actionPerformed(ActionEvent e) {      // Only one method to implement._  
 _System.out.println(e.getActionCommand());     // Prints out "Click me"._  
 _}_  
 _});_

 _// Make the frame closable._  
 _frame.addWindowListener(new WindowAdapter() {_  
 _public void windowClosing(WindowEvent e) {_  
 _System.exit(0);_  
 _}_  
 _});_

 _// Make the frame visible after adding the button._  
 _frame.setVisible(true);_  
 _}_  
_}_

Layout Managers
---------------

_(Ref. [Java® Tutorial](http://java.sun.com/docs/books/tutorial/uiswing/layout/using.html))_

Our previous example has only one interesting GUI component: a _JButton_ . What if we wanted to add a second _JButton_ and perhaps a _JTextArea_, so that we can display the message through the GUI? We can control the layout of these components within the container by using a _layout manager_. Java® comes with six layout managers (five in _java.awt_ and one in _javax.swing_)

_FlowLayout_ - Lays out components in a line from left to right, moving to the next line when out of room. This layout style resembles the flow of text in a document.

_BorderLayout_ - Lays out components in one of five positions - at the North, South, East or West borders, or else in the Center.

_GridLayout_ - Lays out components in rows and columns of equal sized cells, like a spreadsheet.

_GridBagLayout_ - Lays out components on a grid without requiring them to be of equal size. This is the most flexible and also the most complex of all the layout managers.

_CardLayout_ - Lays out components like index cards, one behind another. (No longer useful, now that Swing provides a _JTabbedPane_ component.)

_BoxLayout_ - Lays out components with either vertical alignment or horizontal alignment. (A new layout manager in Swing.)

It is also possible to set a _null_ layout manager and instead position components by specifying their absolute coordinates using the method

    _public void setLocation(int x, int y)_

Suppose we wish to position our two _JButtons_ side by side, with the _JTextArea_ positioned below them. We start by embedding the _JButtons_ within a _JPanel_, using _FlowLayout_ as the layout manager for the _JPanel_. The _JTextArea_ is best placed within a _JScrollPane_ , since this will permit scrolling when the amount of text exceeds the preferred size of the scroll pane. We can now attach the _JPanel_ and the _JScrollPane_ to the North and South borders of the _JFrame_, by using _BorderLayout_ as the layout manager for the _JFrame_. These containment relationships are illustrated below:

{{< tableopen >}}
{{< tropen >}}
{{< tdopen >}}


_JFrame_

{{< tableopen >}}
{{< tropen >}}
{{< tdopen >}}
{{< tableopen >}}
{{< tropen >}}
{{< tdopen >}}


_JPanel_ (attached to the North border of _JFrame_)


{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}


  
 

{{< tableopen >}}
{{< tropen >}}
{{< tdopen >}}


_JButton_


{{< tdclose >}}
{{< tdopen >}}


_JButton_


{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}

(laid out using _FlowLayout_)  
 


{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}

{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}
{{< tableopen >}}
{{< tropen >}}
{{< tdopen >}}


_JScrollPane_ (attached to the South border of _JFrame_)

{{< tableopen >}}
{{< tropen >}}
{{< tdopen >}}


  
_JTextArea_  
 


{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}

{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}

{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}

Here is the implementation:

_import javax.swing.\*;_  
_import java.awt.\*;_  
_import java.awt.event.\*;_

 _public class Main {_  
 _public static void main(String\[\] args) {_  
 _// Create a window and set its layout manager to be BorderLayout._  
 _// (This happens to be the default layout manager for a JFrame.)_  
 _JFrame frame = new JFrame("Main window");_  
 _frame.setSize(400,400);_  
 _Container cf = frame.getContentPane();_  
 _cf.setLayout(new BorderLayout());_

 _// Create a panel and set its layout manager to be FlowLayout._  
 _// (This happens to be the default layout manager for a JPanel.)_  
 _JPanel panel = new JPanel();_  
 _panel.setLayout(new FlowLayout());     // No content pane for JPanel._

 _// Create two buttons and add them to the panel._  
 _JButton button1 = new JButton("Left");_  
 _JButton button2 = new JButton("Right");_  
 _panel.add(button1);_  
 _panel.add(button2);_

 _// Create a text area for displaying messages.  We embed the text_  
 _// area in a scroll pane so that it doesn't grow unboundedly._  
 _JTextArea textArea = new JTextArea();_  
 _JScrollPane scrollPane = new JScrollPane(textArea);_  
 _scrollPane.setPreferredSize(new Dimension(400, 100));_  
 _textArea.setEditable(false);_

 _// Position the panel and the text area within the frame._  
 _cf.add(panel, "North");_  
 _cf.add(scrollPane, "South");_

 _// Add event handlers for button clicks._  
 _class MyListener implements ActionListener {     // A local class._  
 _private JTextArea mTextArea;_  
 _public void setTextArea(JTextArea t) {_  
 _mTextArea = t;_  
 _}_  
 _public void actionPerformed(ActionEvent e) {_  
 _mTextArea.append(e.getActionCommand()+"\\n");_  
 _}_  
 _}_  
 _MyListener listener = new MyListener();_  
 _listener.setTextArea(textArea);      // Cannot do this with an anonymous class._  
 _button1.addActionListener(listener);_  
 _button2.addActionListener(listener);_

 _// Make the frame closable._  
 _frame.addWindowListener(new WindowAdapter() {_  
 _public void windowClosing(WindowEvent e) {_  
 _System.exit(0);_  
 _}_  
 _});_

 _// Make the frame visible after adding the components to it._  
 _frame.setVisible(true);_  
 _}_  
_}_

{{< anchor "4" >}}{{< /anchor >}}4\. Swing Component Overview
-------------------------------------------------------------

The components that we have seen so far are _JFrame_, _JPanel_, _JButton_, _JTextArea_ and _JScrollPane_ . The links below provide a good overview of the Swing components and how to use them.

*   [Visual index to Swing components](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/components.html)
*   [Examples that use Swing](http://java.sun.com/docs/books/tutorial/uiswing/examples/components/index.html)